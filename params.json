{"name":"Mercury","tagline":"Fluent NUnit test extensions","body":"# Mercury\r\n\r\n[![NuGet Version](http://img.shields.io/nuget/v/Mercury.svg?style=flat)](https://www.nuget.org/packages/Mercury/)\r\n[![NuGet Downloads](http://img.shields.io/nuget/dt/Mercury.svg?style=flat)](https://www.nuget.org/packages/Mercury/)\r\n[![Build Status](https://travis-ci.org/MercuryNuGet/Mercury.svg)](https://travis-ci.org/MercuryNuGet/Mercury)\r\n\r\nFluent NUnit specification extensions that will run under NCrunch, and ReSharper test runners.\r\n\r\n#Get started\r\n\r\n##NuGet\r\n\r\n```\r\ninstall-package mercury -pre\r\n```\r\n\r\n##Inherit\r\n\r\nInherit from `SpecificationByMethod` or `Specification` and implement members.\r\n\r\nWith `Specification` you must call `Spec` for each new spec.\r\n\r\n```\r\nusing Mercury;\r\nusing NUnit.Framework;\r\n\r\nnamespace MercuryExample\r\n{\r\n    public class MyTest : SpecificationByMethod\r\n    {\r\n        protected override void Cases()\r\n        {\r\n            Spec(/*see below on writing specs*/);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nWith `Specification` you return an empty array of `ISpecification`. In this array is where you will list your specifications.\r\n\r\n```\r\nusing Mercury;\r\nusing NUnit.Framework;\r\n\r\nnamespace MercuryExample\r\n{\r\n  public class MyTest : Specification\r\n  {\r\n    protected override ISpecification[] TestCases()\r\n    {\r\n        return new ISpecification[]\r\n        {\r\n            /*see below on writing specs*/\r\n        };\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n##Write specifications\r\n\r\nYou can copy and paste these examples directly into the array then run the tests with your favorite test runner.\r\n\r\n###Single assert, no setup\r\n\r\nSimplest spec is just a name and an assert:\r\n\r\n```\r\n\"Simple assert\".Assert(() => Assert.AreEqual(2, 1 + 1)),\r\n```\r\n\r\nThis will emit a single unit test with the text \"Simple assert\" included in the test name.\r\n\r\n###Arrange\r\n\r\nNext most complex is an `Arrange`, this is equivalent to an NUnit `[SetUp]` and runs for each `Assert`,`With` combination (`With`'s are explained later):\r\n\r\n```\r\n\"New List\"\r\n   .Arrange(() => new List<int>())\r\n   .Assert(\"is empty\", list => Assert.AreEqual(0, list.Count)),\r\n```\r\n\r\nClasses under test whose constructors do not take parameters can take advantage of this shorter syntax:\r\n\r\n```\r\n.Arrange<StringBuilder>())\r\n```\r\n\r\nIf you do not require a test context, you can use `Arrange()` with no params or types:\r\n\r\n```\r\n\"No context needed because acting on static method\"\r\n    .Arrange()\r\n    .Act(() => string.Join(\",\", \"a\", \"b\"))\r\n    .Assert(joined => Assert.AreEqual(\"a,b\", joined)),\r\n```\r\n\r\n###Act\r\n\r\nYou can separate out the `Act` from the `Assert`. Here the act invokes `Any()` and the result is passed to the `Assert`.\r\n\r\n```\r\n\"New List; linq says there is not any\"\r\n   .Arrange<List<int>>()\r\n   .Act(list => list.Any())\r\n   .Assert(any => Assert.IsFalse(any)),\r\n```\r\n\r\nOr more succinctly in this case:\r\n\r\n```\r\n\"New List; linq says there is not any\"\r\n   .Arrange<List<int>>()\r\n   .Act(list => list.Any())\r\n   .Assert(Assert.IsFalse),\r\n```\r\n\r\n###ActOn\r\n\r\n`Act` returns the result of it's method. This will not work if the method is `void`. `ActOn` is also way to keep the test context. Example:\r\n\r\n```\r\n\"Act version\"\r\n   .Arrange(() => new List<int>(new []{1, 2, 3}))\r\n   .Act(list =>\r\n   {\r\n     list.Clear();\r\n     return list;\r\n   })\r\n   .Assert(list => Assert.AreEqual(0, list.Count)),\r\n```\r\n\r\nCan be just:\r\n\r\n```\r\n\"ActOn version\"\r\n   .Arrange(() => new List<int>(new []{1, 2, 3}))\r\n   .ActOn(list => list.Clear())\r\n   .Assert(list => Assert.AreEqual(0, list.Count)),\r\n```\r\n\r\n###With\r\n\r\n`With` enables you to parameterise your tests. It takes between 1 and 5 generic parameters. As you can set up anoymous, you can usually get away with just one and then you also get useful names.\r\n\r\n```\r\n\"When I add an item to list\"\r\n   .Arrange<List<int>>()\r\n   .With(new {a=1})\r\n   .ActOn((list, data) => list.Add(data.a))\r\n   .Assert(\"it is exactly one long\",\r\n      (list, data) => Assert.AreEqual(1, list.Count)),\r\n```\r\n\r\n`With` can be used in a situation without a test context using `Arrange()`\r\n\r\n```\r\n\"Test-Context less using with\"\r\n    .Arrange()\r\n    .With(new {a = \"a\", b = \"b\", expect = \"a,b\"})\r\n    .With(new {a = \"c\", b = \"d\", expect = \"c,d\"})\r\n    .Act(data => string.Join(\",\", data.a, data.b))\r\n    .Assert((actual, data) => Assert.AreEqual(data.expect, actual)),\r\n```\r\n\r\n`With` when used with mutiple data items gives more assert styles:\r\n\r\n```\r\n\"Multiple data arguments in with, and three assert styles\"\r\n    .ArrangeNull()\r\n    .With(\"a\", \"b\", \"a,b\")\r\n    .With(\"c\", \"d\", \"c,d\")\r\n    .Act((_, a, b, expected) => string.Join(\",\", a, b))\r\n    .Assert((result, a, b, expected) => Assert.AreEqual(expected, result))\r\n    .Assert((result, expected) => Assert.AreEqual(expected, result))\r\n    .AssertEqualsExpected(),\r\n```\r\n\r\n###Multiple Withs and parameter injection to test name\r\n\r\nUse the `#` symbol to inject named parameters from your `With` data type.\r\n\r\n```\r\n\"When I add #a item to list\"\r\n   .Arrange<List<int>>()\r\n   .With(new {a=1})\r\n   .With(new {a=2})\r\n   .ActOn((list, data) => list.Add(data.a))\r\n   .Assert(\"it is exactly one long\",\r\n      (list, data) => Assert.AreEqual(1, list.Count)),\r\n```\r\n\r\nThis emits two tests:\r\n\r\n```\r\nWhen I add 1 item to list it is exactly one long\r\nWhen I add 2 item to list it is exactly one long\r\n```\r\n\r\n###Multiple Withs and Asserts\r\n\r\nThe total number of tests emitted is the number of `Assert`s multiplied by the number of `With`s. This test below therefore runs 4 tests.\r\n\r\n```\r\n\"When I add #a to list\"\r\n   .Arrange<List<int>>()\r\n   .With(new {a=1})\r\n   .With(new {a=2})\r\n   .ActOn((list, data) => list.Add(data.a))\r\n   .Assert(\"it is exactly one long\",\r\n      (list, data) => Assert.AreEqual(1, list.Count))\r\n   .Assert(\"it contains #a\",\r\n      (list, data) => Assert.AreEqual(data.a, list[0])),\r\n```\r\n\r\n###Place expected values in the data\r\n\r\nWhere each `With` will generate a different expected value, include those expected values in the `With` data.\r\n\r\n```\r\n\"When I add #expectedLength items to list\"\r\n   .Arrange<List<int>>()\r\n   .With(new {a=new []{1,2,3},   expectedLength=3, expectedSum=6})\r\n   .With(new {a=new []{4,6,7,9}, expectedLength=4, expectedSum=26})\r\n   .ActOn((list, data) => list.AddRange(data.a))\r\n   .Assert(\"it is exactly #expectedLength long\",\r\n      (list, data) => Assert.AreEqual(data.expectedLength, list.Count))\r\n   .Assert(\"the sum is #expectedSum\",\r\n      (list, data) => Assert.AreEqual(data.expectedSum, list.Sum())),\r\n```\r\n\r\n###`SpecificationByMethod` advantages\r\n\r\n```\r\nclass SpecByMethodExample : SpecificationByMethod\r\n{\r\n    protected override void Cases()\r\n    {\r\n        Spec(\"Example of spec defined in method\".Assert(() => Assert.AreEqual(2, 1 + 1)));\r\n\r\n        Spec(\"Lets you space out tests\".Assert(() => Assert.AreEqual(2, 1 + 1)));\r\n\r\n        for (int i = 0; i < 10; i++)\r\n        {\r\n            Spec(\"And even lets you create specs dynamically #i\"\r\n                .Arrange()\r\n                .With(new {i})\r\n                .Act(data => data.i*10)\r\n                .Assert((result, data) => Assert.IsTrue(result%10 == 0)));\r\n        }\r\n    }\r\n}\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}