<#@ template language="C#" hostspecific="True"#>
<#@ include file="Manager.ttinclude"#>
<# var manager = Manager.Create(Host, GenerationEnvironment); #>

<# manager.StartHeader(); #>
// Code generated by a template
using System;
using Mercury.AssertBuilder;
<# manager.EndBlock(); #>
<# const int maxDataTypes = 5;

    Func<int, string> createDataTypeCsvList = count =>
    {
        if (count == 1) return "TData";
        var list = new List<string>();
        for (var d = 1; d <= count; d++)
        {
            list.Add("TData" + d);
        }
        return string.Join(", ", list);
    };

    Func<int, string> createOutDataTypeCsvList = count =>
    {
        if (count == 1) return "out TData";
        var list = new List<string>();
        for (var d = 1; d <= count; d++)
        {
            list.Add("out TData" + d);
        }
        return string.Join(", ", list);
    };

    Func<int, string> createDataArgSig = count =>
    {
        if (count == 1) return "TData data";
        var list = new List<string>();
        for (var d = 1; d <= count; d++)
        {
            list.Add("TData" + d + " data" + d);
        }
        return string.Join(", ", list);
    };

    Func<string, int, string> tupleToArgCsv = (name, count) =>
    {
        var list = new List<string>();
        for (var d = 1; d <= count; d++)
        {
            list.Add(name + ".Item" + d);
        }
        return string.Join(", ", list);
    };

    Func<string, int, string> newArgList = (name, count) =>
    {
        if (count == 1) return name;
        var list = new List<string>();
        for (var d = 1; d <= count; d++)
        {
            list.Add(name + d);
        }
        return string.Join(", ", list);
    };

	 Action<int,string> writeSuiteFieldDefinition = (count,tupleType) =>
	 {
	     if (count > 0)
	         Write("private readonly IDataSuite<" + tupleType + "> _dataSuite;");
	     else
	         Write("private readonly ISuite _suite;");
	 };
#>

namespace Mercury
{
    public interface IArranged<out TSut>
    {
        IAssertCaseBuilder<TPostAct> Act<TPostAct>(Func<TSut, TPostAct> actFunc);
<#
{
    for (var k = 1; k <= maxDataTypes; k++)
    {
        var types = createDataTypeCsvList(k);
        var sig = createDataArgSig(k);
#>
	    IArrangedWithData<TSut, <#Write(types); #>> With<<#Write(types); #>>(<#Write(sig); #>);
<#
    }
}
#>
    }

	namespace Arrange
	{
		internal sealed class ArrangedTestBuilder<TSut> : IArranged<TSut>, ISuite
    	{
        	private readonly string _testName;
        	private readonly Func<TSut> _arrangeFunc;

        	public ArrangedTestBuilder(string testName, Func<TSut> arrangeFunc)
        	{
            	_testName = testName;
            	_arrangeFunc = arrangeFunc;
        	}

        	public IAssertCaseBuilder<TResult> Act<TResult>(Func<TSut, TResult> actFunc)
        	{
            	return new PreAssertBuilder<TResult>(this, () => actFunc(_arrangeFunc()));
        	}

<#
{
    for (var k = 1; k <= maxDataTypes; k++)
    {
        var types = createDataTypeCsvList(k);
        var sig = createDataArgSig(k);
        var args = newArgList("data", k);
#>
        	public IArrangedWithData<TSut, <#Write(types); #>> With<<#Write(types); #>>(<#Write(sig); #>)
        	{
                return new ArrangedDataBuilder<TSut, <#Write(types); #>>(this, _arrangeFunc).With(<#Write(args); #>);
        	}

<#
    }
}
#>
            public string SuiteName
            {
                get { return _testName; }
            }
        }
    }
}
<#
for (var dataTypeCount = 0; dataTypeCount <= maxDataTypes; dataTypeCount++)
{
    var allDataTypesWithoutPrefixPostfix = createDataTypeCsvList(dataTypeCount);
    var allDataTypes = allDataTypesWithoutPrefixPostfix == "" ? "" : ", " + allDataTypesWithoutPrefixPostfix;
    var allDataTypesPost = allDataTypesWithoutPrefixPostfix == "" ? "" : allDataTypesWithoutPrefixPostfix + ", ";
    var allDataTypesWithOut = createOutDataTypeCsvList(dataTypeCount);
    var allDataTypesWithOutPre = allDataTypesWithOut == "" ? "" : ", " + allDataTypesWithOut;
    var sig = createDataArgSig(dataTypeCount);
    var tupleType = dataTypeCount == 1 ? "TData" : "Tuple<" + allDataTypesWithoutPrefixPostfix + ">";
    if (dataTypeCount >= 0)
    {
        manager.StartNewFile("DataX" + dataTypeCount + ".generated.cs");
        #>
namespace Mercury
{
  public interface IArrangedWithData<out TSut<# Write(allDataTypes); #>>
  {
     IAssertCaseBuilder<TPostAct<# Write(allDataTypes); #>> Act<TPostAct>(Func<TSut<# Write(allDataTypes); #>, TPostAct> actFunc);
     IArrangedWithData<TSut<# Write(allDataTypes); #>> With(<#Write(sig); #>);
  }

  public interface IAssertCaseBuilder<out TSut<# Write(allDataTypesWithOutPre); #>>
  {
      IPostAssertCaseBuilder<TSut<# Write(allDataTypes); #>> Assert(Action<TSut<# Write(allDataTypes); #>> assertAction);
      IPostAssertCaseBuilder<TSut<# Write(allDataTypes); #>> Assert(string assertionTestCaseName, Action<TSut<# Write(allDataTypes); #>> assertAction);
  }

  public interface IPostAssertCaseBuilder<out TSut<# Write(allDataTypesWithOutPre); #>> : ISpecification,
        IAssertCaseBuilder<TSut<# Write(allDataTypes); #>>
  {
  }
}
<# }
manager.EndBlock(); #>
<#manager.StartNewFile("AssertBuilderX" + dataTypeCount + ".generated.cs"); #>
using System.Collections.Generic;

namespace Mercury.AssertBuilder
{
  internal sealed class AssertBuilder<TSut<# Write(allDataTypes); #>> : IPostAssertCaseBuilder<TSut<# Write(allDataTypes); #>>
  {
        private readonly TestCaseAccumulator _tests = new TestCaseAccumulator();
        private readonly Func<<# Write(allDataTypesPost); #>TSut> _actFunc;
		<# writeSuiteFieldDefinition(dataTypeCount, tupleType); #>


        public AssertBuilder(Func<<# Write(allDataTypesPost); #>TSut> actFunc,
<# if (dataTypeCount == 0)
{ #>
                           ISuite suite)
<# }
else
{ #>
                           IDataSuite<<# Write(tupleType); #>> dataSuite)
<# } #>
        {
            _actFunc = actFunc;
<# if (dataTypeCount > 0)
{ #>
            _dataSuite = dataSuite;
<# }
else
{ #>
            _suite = suite;
<# } #>
        }

        public IPostAssertCaseBuilder<TSut<# Write(allDataTypes); #>> Assert(Action<TSut<# Write(allDataTypes); #>> assertMethod)
        {
		    InternalAssert(_<# Write(dataTypeCount == 0 ? "s" : "dataS"); #>uite.SuiteName, assertMethod);
            return this;
        }

        public IPostAssertCaseBuilder<TSut<# Write(allDataTypes); #>> Assert(string assertionTestCaseName,
            Action<TSut<# Write(allDataTypes); #>> assertMethod)
        {
            InternalAssert(_<# Write(dataTypeCount == 0 ? "s" : "dataS"); #>uite.SuiteName + " " + assertionTestCaseName, assertMethod);
            return this;
        }

        private void InternalAssert(string testName, Action<TSut<# Write(allDataTypes); #>> assertMethod)
        {
<# if (dataTypeCount > 0)
{ #>
            foreach (var data in _dataSuite.Data)
            {
                var d = data;
                string inject = NameInjection.Inject(testName, d);
                Action assertTestMethod = () =>
                {
<#
    var allDataItemsCsv = dataTypeCount == 1 ? "d" : tupleToArgCsv("d", dataTypeCount);
#>
                    TSut acted = _actFunc(<#Write(allDataItemsCsv); #>);
                    assertMethod(acted, <#Write(allDataItemsCsv); #>);
                };
                _tests.AddSingleTest(inject, assertTestMethod);
            }
<# } else
{ #>
            _tests.AddSingleTest(testName, () => assertMethod(_actFunc()));            
<# } #>
        }

        public IEnumerable<ISingleRunnableTestCase> EmitAllRunnableTests()
        {
            return _tests.EmitAllRunnableTests();
        }
    }
}
<#manager.EndBlock(); #>
<#manager.StartNewFile("PreAssertBuilderX" + dataTypeCount + ".generated.cs"); #>
using System.Collections.Generic;

namespace Mercury.AssertBuilder
{
	internal sealed class PreAssertBuilder<TSut<# Write(allDataTypes); #>> : IAssertCaseBuilder<TSut<# Write(allDataTypes); #>>
    {
        private readonly Func<<# Write(allDataTypesPost); #>TSut> _actFunc;
        <# writeSuiteFieldDefinition(dataTypeCount, tupleType); #>


        public PreAssertBuilder(<# if (dataTypeCount == 0)
{ #>
ISuite suite<# }
else
{ #>
IDataSuite<<# Write(tupleType); #>> dataSuite<# } #>, Func<<# Write(allDataTypesPost); #>TSut> actFunc)
        {
            _actFunc = actFunc;
<# if (dataTypeCount > 0)
{ #>
            _dataSuite = dataSuite;
<# }
else
{ #>
            _suite = suite;
<# } #>
        }

        public IPostAssertCaseBuilder<TSut<# Write(allDataTypes); #>> Assert(Action<TSut<# Write(allDataTypes); #>> assertAction)
        {
            return new AssertBuilder<TSut<# Write(allDataTypes); #>>(_actFunc, _<# Write(dataTypeCount == 0 ? "s" : "dataS"); #>uite).Assert(assertAction);
        }

        public IPostAssertCaseBuilder<TSut<# Write(allDataTypes); #>> Assert(string assertionTestCaseName,
            Action<TSut<# Write(allDataTypes); #>> assertAction)
        {
            return new AssertBuilder<TSut<# Write(allDataTypes); #>>(_actFunc, _<# Write(dataTypeCount == 0 ? "s" : "dataS"); #>uite).Assert(assertionTestCaseName,
                assertAction);
        }
    }
}
<# manager.EndBlock(); #>
<#
if (dataTypeCount > 0)
{
    manager.StartNewFile("ArrangedDataBuilderX" + dataTypeCount + ".generated.cs"); #>
using System.Collections.Generic;

namespace Mercury.Arrange
{
	internal sealed class ArrangedDataBuilder<TSut<# Write(allDataTypes); #>> : IArrangedWithData<TSut<# Write(allDataTypes); #>>, IDataSuite<<# Write(tupleType); #>>
    {
        private readonly ISuite _suite;
        private readonly Func<TSut> _arrangeFunc;
        private readonly List<<# Write(tupleType); #>> _data = new List<<# Write(tupleType); #>>();

        public ArrangedDataBuilder(ISuite suite, Func<TSut> arrangeFunc)
        {
            _suite = suite;
            _arrangeFunc = arrangeFunc;
        }

        public IAssertCaseBuilder<TPostAct<# Write(allDataTypes); #>> Act<TPostAct>(Func<TSut<# Write(allDataTypes); #>, TPostAct> actFunc)
        {
<#{
    var argList = newArgList("data", dataTypeCount);
#>
            return new PreAssertBuilder<TPostAct<# Write(allDataTypes); #>>(
			    this,
                (<#Write(argList); #>) =>
                {
                    var arranged = _arrangeFunc();
                    return actFunc(arranged, <#Write(argList); #>);
                });
<# } #>
        }

        public IArrangedWithData<TSut<# Write(allDataTypes); #>> With(<# Write(createDataArgSig(dataTypeCount)); #>)
        {
<# if (dataTypeCount == 1)
{ #>
            _data.Add(<# Write(newArgList("data", dataTypeCount)); #>);
<# }
else
{ #>
            _data.Add(Tuple.Create(<# Write(newArgList("data", dataTypeCount)); #>));
<# } #>
            return this;
        }

        public string SuiteName
        {
            get { return _suite.SuiteName; }
        }

        public IEnumerable<<# Write(tupleType); #>> Data
        {
            get { return _data; }
        }
    }
    }
<# manager.EndBlock(); #>
<# manager.StartNewFile("ExtensionsX" + dataTypeCount + ".generated.cs");

    Func<int, string> createExtensionTypes = count =>
    {
        var list = new List<string>();
		list.Add("TActual");
        for (var d = 1; d < count; d++)
        {
            list.Add("TUnusedData" + d);
        }
		list.Add("TExpected");
        return string.Join(", ", list);
    };

	Func<int, string> createExtensionArgs = count =>
    {
        var list = new List<string>();
		list.Add("actual");
        for (var d = 1; d < count; d++)
        {
            list.Add("unusedData" + d);
        }
		list.Add("expected");
        return string.Join(", ", list);
    };

	var extensionTypes = createExtensionTypes(dataTypeCount);
	var extensionArgs = createExtensionArgs(dataTypeCount);
#>
using System.Collections.Generic;

namespace Mercury
{
    public static class ExtensionsX<# Write(dataTypeCount.ToString()); #> {

<# if (dataTypeCount > 1) {#>
        /// <summary>
        ///    Assert that passes result of act and last data item to function. Useful when placing expected as last data item.
        /// </summary>
        /// <typeparam name="TActual"></typeparam>
<# for(var counter = 1; counter < dataTypeCount; counter++) {#>
        /// <typeparam name="TUnusedData<# Write(counter.ToString()); #>"></typeparam>
<# } #>
        /// <typeparam name="TExpected"></typeparam>
        /// <param name="builder"></param>
        /// <param name="assertMethod"></param>
        /// <returns></returns>
        public static IPostAssertCaseBuilder<<# Write(extensionTypes); #>> Assert<<# Write(extensionTypes); #>>(
		      this IAssertCaseBuilder<<# Write(extensionTypes); #>> builder,
		           Action<TActual, TExpected> assertMethod){
            return builder.Assert((<# Write(extensionArgs); #>) => assertMethod(actual, expected));
        }

		/// <summary>
        ///    Assert that passes result of act and last data item to function. Useful when placing expected as last data item.
        /// </summary>
        /// <typeparam name="TActual"></typeparam>
<# for(var counter = 1; counter < dataTypeCount; counter++) {#>
        /// <typeparam name="TUnusedData<# Write(counter.ToString()); #>"></typeparam>
<# } #>
        /// <typeparam name="TExpected"></typeparam>
        /// <param name="builder"></param>
		/// <param name="assertName"></param>
        /// <param name="assertMethod"></param>
        /// <returns></returns>
		public static IPostAssertCaseBuilder<<# Write(extensionTypes); #>> Assert<<# Write(extensionTypes); #>>(
		        this IAssertCaseBuilder<<# Write(extensionTypes); #>> builder,
		             string assertName,
				     Action<TActual, TExpected> assertMethod){
            return builder.Assert(assertName, (<# Write(extensionArgs); #>) => assertMethod(actual, expected));
        }
<# } #>

    }
}
<#
}
    manager.EndBlock();
}
#>
<# manager.StartFooter(); #>
<# manager.EndBlock(); #>
<# manager.Process(true); #>